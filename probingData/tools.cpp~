
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string>
#include <math.h>


inline STREAM_FAIL(char* FROM_FILE, int AT_LINE, char* IN_FUNCTION) {printf("STREAM_FAILURE, line %d, function %s, file %s\n", LINE, IN_FUNCTION, THE_FILE);return EXIT_FAILURE};
inline MEMO_FAIL(char* FROM_FILE, int AT_LINE, char* IN_FUNCTION) {printf("MEMO_ALLOC_FAILURE, line %d, function %s, file %s\n", LINE, IN_FUNCTION, THE_FILE);;return EXIT_FAILURE};


/*** Structures
 */
// Each node have coordinates
typedef struct aNode {
	int index;// Unique, defines a point : for either a ground node or a uav
	double x;
	double y;
}aNode;


// A UaV is also a node
// Even though igraph uses specific type, this structure that specifies the coordinates of a UaV in the netwprk
typedef struct aUav{
	aNode identif;
	//long gene=0;
	int covers;	// A UaV contains at least 0 ground nodes
	double range;  	// If "contains" < 0 then is ground node and its range is also < 1
	bool active;  // ground nodes are always unactive. a uav can also be
}aUav;
*/


/** Variables
 */
// general variables
int nbr_subpop;			// number of subpopulations using different strategies
int nbr_gen;			// number of generations
int nbr_inds;			// number of individuals (slns)
int nbr_grnds;			// number of ground nodes
int nbr_uavs;			// number of UaVs for an individ
int max_uav_avail;		// the total number of uavs available
int nbr_objs;			// 3 : CO, FTO, RO
int nbr_constraints;	// connectivity cstraint, bounds
int bound_1;			// Limits in 2D space : lower bound for all : 0
int bound_2;
int nbr_clones;			// nombre of clones to remove in one generation

// stopping criteria and evolutionary parameters
int max_time; // limit on the processing time
int no_improv_ites; // for "no_improv_ites" iterations where the fitness difference in fitness (improvements) is less than "epsilon", then stop
double epsilon;
double mutaprob;
double evo_part_percent;
double grasp_part_percent;
double grasp_split;// Correspond au pourcentage de population grasp
							// => PopSize*k ici 50% si supérieur ou égale à 1 valeur brute d'individu par direction
int n_delta;// number of grasp directions
double alpha;// RCL restricting coefficient
bool parentarena = 1 ;	// tournament in picking parents (1), or not (0)
double rank1maxsize = 0.5 ;	// Correspond au pourcentage de la population que peut représenter le rang 1, augmentation de la taille de la population si supérieur.
double crowdSave = 0.1 ;	// Correspond au pourcentage de la population sauver par la seconde valeur de crowding, si supérieur à 1 valeur brute d'individu sauvé
double crowdTotal = 0.5 ;	// Correspond au pourcentage de rang que l'on considère pour le calcul du crowding2, ici 50%.
int HyperVolCD = 10 ;
double* GRASPFIT;	// with respect to coefficients grasp, fitness values

// Data visualisation choices
bool TESTMODE=1; // display NSGA-II infos (1), or not (0).
bool gnuplot=1; // plot results
bool results=1; // print results on terminal
bool removeclone=1;	// 1, do not remove generated clones, 0 otherwise

// Set of ground nodes 
aNode* GRNDS;		// All ground nodes coordinates
double* UAVs_Range;	// all ranges of available uavs

/** Functions
 */

// *To develop later if possible*
//long* encodeGene(aUav uav);
//aUav decodeGene(long* gene_indiv);

bool readData(char** argv);
bool inRange(aUav* uav, aNode* ground);
void writeData(sln* a_sln);
void freeIndiv(Individu* indiv_to_copy);
void free2D(double** to_free, int n_rows, int n_cols)


#endif

void readData(char** argv)
{
	FILE* fp;
	char *tmp[100];// Just a buffer
	int tmp2;// this one too

	// parameters
	fp=fopen(argv[1],"r");
	if( !fp ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}

	// Problem parameters
	if( fscanf(fp,"%s", tmp) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// "PRBLM_CRIT", text not needed
	if( fscanf(fp,"%s %d", tmp, &nbr_inds) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// Number of solutions by generations
	if( fscanf(fp,"%s %lf", tmp, &mutaprob) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// Number of generations to perform
	if( fscanf(fp,"%s %lf", tmp, &rank1maxsize) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	if( fscanf(fp,"%s %lf", tmp, &crowdSave) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	if( fscanf(fp,"%s %lf", tmp, &crowdTotal) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	//	fscanf(fp,"%[^:]:%lf", &aha[0], &ahaa, &ahao);// Alternative of reading instream

	// stopping criteria
	if( fscanf(fp,"%s", tmp) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// "STOP_CRIT", text not needed
	if( fscanf(fp,"%s %d", tmp, &max_time) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// Number of generations to perform
	if( fscanf(fp,"%s %d", tmp, &nbr_gen) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// Number of generations to perform
	if( fscanf(fp,"%s %d", tmp, &no_improv_ites) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// Number of iterations allowed to continue with where the improvements of fitness is less than "epsilon"
	if( fscanf(fp,"%s %lf", tmp, &epsilon) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// see previous line
	if( fscanf(fp,"%s %d", tmp, &hyper_vol_CD) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// needed to compute the HyperVolume for NSGA-II
	if( fscanf(fp,"%s %lf", tmp, &evo_part_percent) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}//
	if( fscanf(fp,"%s %lf", tmp, &grasp_part_percent) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}//

	// grasp parameters
	if( fscanf(fp,"%s", tmp) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// "GRASP_CRIT", text not needed
	if( fscanf(fp,"%s %lf", tmp, &grasp_split) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	if( fscanf(fp,"%s %d", tmp, &n_delta) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	if( fscanf(fp,"%s %lf", tmp, &alpha) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}

	// NSGA-II parameters
	if( fscanf(fp,"%s", tmp) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}// "NSGA_CRIT", text not needed
	if( fscanf(fp,"%s %d", tmp, &tmp2) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	TESTMODE=(tmp2==1?true : false);
	if( fscanf(fp,"%s %d", tmp, &tmp2) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	removeclone=(tmp2==1?true : false);
	if( fscanf(fp,"%s %d", tmp, &tmp2) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	parentarena=(tmp2==1?true : false);
	if( fscanf(fp,"%s %d", tmp, &tmp2) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	gnuplot=(tmp2==1?true : false);
	if( fscanf(fp,"%s %d", tmp, &tmp2) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}
	results=(tmp2==1?true : false);

	fclose(fp);


	// read data (coordinates ground nodes)
	fp=fopen(argv[2],"r");

	// read number of available uavs
	if( fscanf(fp,"%d", &max_uav_avail) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}	
	UAVs_Range=malloc(max_uav_avail*sizeof(double));
	int i=0;
	// read range of each of them 
	for(i=0;i<max_uav_avail;i++)
		fscanf(fp,"%lf", &UAVs_Range[i]);


	// read number of ground nodes and then the coordinates
	if( fscanf(fp,"%d", &nbr_grnds) < 0 ){STREAM_FAIL(__FILE__, __LINE__, __FUNCTION__);}

	/* allocate memory for ground nodes */
	GRNDS=malloc(nbr_grnds*sizeof(aNode));
	if(GRNDS==NULL){ /* memory allocation failure */ MEMO_FAIL(__LINE__, __FILE__, __FUNCTION__); }

	for(i=0;i<nbr_grnds;i++)
	{
		GRNDS[i].index=i;// Unique, defines a point : for either a ground node or a uav
		fscanf(fp,"%lf,%lf", &GRNDS[i].x, &GRNDS[i].y);
	}

	fclose(fp);
}


void writeData(sln a_sln){
	int i=0;
	FILE *f;
	char path[30];
	char buff[30];
/*
	strcpy(path,"../optimum/optimum250.txt");
	strcpy(buff,argv[4]);
	strtok(buff,"/");
	strcat(path,strtok(NULL,"/"));

	f=fopen(path,"w");
*/	
}


/** 	\brief Check wether the ground node is covered by the uav
 *		\param a pointer on the uav 
 */
bool inRange(aUav* uav, aNode* ground)
{
	return ( sqrt( pow2( uav->idx - ground->x ) + pow2( uav->y - ground->y ) ) > range ? false, true);
};
